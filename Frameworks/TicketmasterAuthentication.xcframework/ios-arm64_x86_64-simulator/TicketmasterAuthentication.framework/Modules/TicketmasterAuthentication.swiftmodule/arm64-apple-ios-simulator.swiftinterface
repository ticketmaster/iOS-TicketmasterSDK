// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios16.6-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name TicketmasterAuthentication
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import AuthenticationServices
import CryptoKit
import DeveloperToolsSupport
import DeviceCheck
import Foundation
import LocalAuthentication
import SafariServices
import Security
import Swift
import SwiftUI
@_exported import TicketmasterAuthentication
import TicketmasterFoundation
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
extension TicketmasterAuthentication.TMAuthentication {
  final public func configure(apiKey: Swift.String, region: TicketmasterAuthentication.TMAuthentication.TMXDeploymentRegion = .US, environment: TicketmasterAuthentication.TMAuthentication.TMXDeploymentEnvironment = .Production, branding: TicketmasterAuthentication.TMAuthentication.Branding? = nil, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, success: @escaping (_ backendsConfigured: [TicketmasterAuthentication.TMAuthentication.BackendService]) -> Swift.Void, failure: @escaping (_ error: any Swift.Error) -> Swift.Void)
  final public func configure(tmxSettings: TicketmasterAuthentication.TMAuthentication.TMXSettings, branding: TicketmasterAuthentication.TMAuthentication.Branding? = nil, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, success: @escaping (_ backendsConfigured: [TicketmasterAuthentication.TMAuthentication.BackendService]) -> Swift.Void, failure: @escaping (_ error: any Swift.Error) -> Swift.Void)
  final public func configure(brandedServiceSettings: TicketmasterAuthentication.TMAuthentication.BrandedServiceSettings, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, success: @escaping (_ backendsConfigured: [TicketmasterAuthentication.TMAuthentication.BackendService]) -> Swift.Void, failure: @escaping (_ error: any Swift.Error) -> Swift.Void)
}
extension TicketmasterAuthentication.TMAuthentication {
  final public func apigeeConfig(backend: TicketmasterAuthentication.TMAuthentication.BackendService? = nil, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, success: @escaping (_ config: TicketmasterAuthentication.TMApigeeConfig) -> Swift.Void, failure: @escaping (_ error: any Swift.Error) -> Swift.Void)
  final public func apigeeConfig(tmxSettings: TicketmasterAuthentication.TMAuthentication.TMXSettings, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, success: @escaping (_ config: TicketmasterAuthentication.TMApigeeConfig) -> Swift.Void, failure: @escaping (_ error: any Swift.Error) -> Swift.Void)
}
extension TicketmasterAuthentication.TMAuthentication {
  final public func tmxNetworkServiceConfig(backend: TicketmasterAuthentication.TMAuthentication.BackendService? = nil) -> TicketmasterAuthentication.TMXNetworkServiceConfig?
  final public func backendServicesConfigured(source: TicketmasterAuthentication.TMAuthentication.AuthSource? = nil, instanceID: Swift.String? = nil) -> [TicketmasterAuthentication.TMAuthentication.BackendService]
  final public func removeAllConfiguredBackendServices(completion: @escaping (_ success: Swift.Bool) -> Swift.Void)
}
public struct TMXNetworkServiceConfig : Swift.Codable, Swift.Hashable {
  public let backendService: TicketmasterAuthentication.TMAuthentication.BackendService
  public let brandedServiceSettings: TicketmasterAuthentication.TMAuthentication.BrandedServiceSettings
  public let localeString: Swift.String
  public let deviceGUID: Foundation.UUID
  public let responseInfo: TicketmasterAuthentication.TMXNetworkServiceConfig.ResponseInfo?
  public struct ResponseInfo : Swift.Codable, Swift.Hashable {
    public let sessionBID: Swift.String?
    public let sessionSID: Swift.String?
    public let gameDayEnabled: Swift.Bool?
    public let gameDayURL: Foundation.URL?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMXNetworkServiceConfig.ResponseInfo, b: TicketmasterAuthentication.TMXNetworkServiceConfig.ResponseInfo) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TicketmasterAuthentication.TMXNetworkServiceConfig, b: TicketmasterAuthentication.TMXNetworkServiceConfig) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public protocol TMAuthenticationProvider : AnyObject {
  var useCombinedLogin: Swift.Bool { get set }
  var forceEphemeralWebBrowserSession: Swift.Bool? { get set }
  var disableSystemExchangeDuringLogin: Swift.Bool { get set }
  func registerStateChanged(block: @escaping (_ backend: TicketmasterAuthentication.TMAuthentication.BackendService?, _ state: TicketmasterAuthentication.TMAuthentication.ServiceState, _ error: (any Swift.Error)?) -> Swift.Void)
  func clearAllStateChangedBlocks()
  func loginSelectionPage(backend: TicketmasterAuthentication.TMAuthentication.BackendService?, loginProperties: [Swift.String : Swift.String]?, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule?, callSource: Swift.String?) -> UIKit.UIViewController?
  func login(backend: TicketmasterAuthentication.TMAuthentication.BackendService?, externalToken: Swift.String?, loginProperties: [Swift.String : Swift.String]?, presentationViewController: UIKit.UIViewController?, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule?, callSource: Swift.String?, success: @escaping (_ authToken: TicketmasterAuthentication.TMAuthToken) -> Swift.Void, aborted: @escaping (_ oldAuthToken: TicketmasterAuthentication.TMAuthToken?, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService) -> Swift.Void, failure: @escaping (_ oldAuthToken: TicketmasterAuthentication.TMAuthToken?, _ error: any Swift.Error, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Void)
  func hasToken(backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Bool
  func hasUnexpiredToken(backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Bool
  func validToken(backend: TicketmasterAuthentication.TMAuthentication.BackendService?, showLoginIfNeeded: Swift.Bool, loginProperties: [Swift.String : Swift.String]?, presentationViewController: UIKit.UIViewController?, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule?, callSource: Swift.String?, success: @escaping (_ authToken: TicketmasterAuthentication.TMAuthToken) -> Swift.Void, aborted: @escaping (_ oldAuthToken: TicketmasterAuthentication.TMAuthToken?, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService) -> Swift.Void, failure: @escaping (_ oldAuthToken: TicketmasterAuthentication.TMAuthToken?, _ error: any Swift.Error, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Void)
  func memberInfo(backend: TicketmasterAuthentication.TMAuthentication.BackendService?, relatedAccount: TicketmasterAuthentication.TMMemberInfo.RelatedAccount?, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule?, callSource: Swift.String?, success: @escaping (_ memberInfo: TicketmasterAuthentication.TMMemberInfo) -> Swift.Void, failure: @escaping (_ oldMemberInfo: TicketmasterAuthentication.TMMemberInfo?, _ error: any Swift.Error, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Void)
  func validateMFAToken(backend: TicketmasterAuthentication.TMAuthentication.BackendService?, mfaProperties: [Swift.String : Any]?, presentationViewController: UIKit.UIViewController?, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule?, callSource: Swift.String?, success: @escaping (_ mfaToken: TicketmasterAuthentication.TMMFAToken) -> Swift.Void, aborted: @escaping (_ backend: TicketmasterAuthentication.TMAuthentication.BackendService) -> Swift.Void, failure: @escaping (_ error: any Swift.Error, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Void)
  func logout(backend: TicketmasterAuthentication.TMAuthentication.BackendService?, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule?, callSource: Swift.String?, completion: @escaping (_ backends: [TicketmasterAuthentication.TMAuthentication.BackendService]?) -> Swift.Void)
  func logoutAll(fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule?, callSource: Swift.String?, completion: @escaping (_ backends: [TicketmasterAuthentication.TMAuthentication.BackendService]?) -> Swift.Void)
  func deleteAccount(backend: TicketmasterAuthentication.TMAuthentication.BackendService?, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule?, callSource: Swift.String?, success: @escaping (_ backend: TicketmasterAuthentication.TMAuthentication.BackendService) -> Swift.Void, aborted: @escaping (_ backend: TicketmasterAuthentication.TMAuthentication.BackendService) -> Swift.Void, failure: @escaping (_ error: any Swift.Error, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Void)
  func clearAllCachedData(callSource: Swift.String?, completion: @escaping () -> Swift.Void)
}
public protocol TMApigeeConfigurationProvider : AnyObject {
  func apigeeConfig(backend: TicketmasterAuthentication.TMAuthentication.BackendService?, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule?, success: @escaping (_ config: TicketmasterAuthentication.TMApigeeConfig) -> Swift.Void, failure: @escaping (_ error: any Swift.Error) -> Swift.Void)
  func apigeeConfig(tmxSettings: TicketmasterAuthentication.TMAuthentication.TMXSettings, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule?, success: @escaping (_ config: TicketmasterAuthentication.TMApigeeConfig) -> Swift.Void, failure: @escaping (_ error: any Swift.Error) -> Swift.Void)
  func tmxNetworkServiceConfig(backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> TicketmasterAuthentication.TMXNetworkServiceConfig?
  func backendServicesConfigured(source: TicketmasterAuthentication.TMAuthentication.AuthSource?, instanceID: Swift.String?) -> [TicketmasterAuthentication.TMAuthentication.BackendService]
  func removeAllConfiguredBackendServices(completion: @escaping (_ success: Swift.Bool) -> Swift.Void)
}
public protocol TMDeviceBindingProvider : AnyObject {
  func boundDeviceIdSignature(backend: TicketmasterAuthentication.TMAuthentication.BackendService?, callSource: Swift.String, infoToEncode: TicketmasterAuthentication.TMAuthentication.InfoToEncode, success: @escaping (_ deviceKey: TicketmasterAuthentication.TMDeviceKey) -> Swift.Void, failure: @escaping (_ error: any Swift.Error, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Void)
  func bindNewDeviceKey(backend: TicketmasterAuthentication.TMAuthentication.BackendService?, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule?, callSource: Swift.String, success: @escaping (_ remainingKeys: Swift.Int?) -> Swift.Void, failure: @escaping (_ error: any Swift.Error, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Void)
}
public protocol TMAuthenticationExternalTokenProvider : AnyObject {
  func refresh(backend: TicketmasterAuthentication.TMAuthentication.BackendService, oldExternalToken: Swift.String, showLoginIfNeeded: Swift.Bool, success: @escaping (_ refreshedExternalToken: Swift.String) -> Swift.Void, aborted: @escaping () -> Swift.Void, failure: @escaping (_ error: any Swift.Error) -> Swift.Void)
}
extension TicketmasterAuthentication.TMAuthentication {
  final public func deleteAccount(backend: TicketmasterAuthentication.TMAuthentication.BackendService? = nil, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, callSource: Swift.String? = nil, success: @escaping (_ backend: TicketmasterAuthentication.TMAuthentication.BackendService) -> Swift.Void, aborted: @escaping (_ backend: TicketmasterAuthentication.TMAuthentication.BackendService) -> Swift.Void, failure: @escaping (_ error: any Swift.Error, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Void)
}
extension TicketmasterAuthentication.TMAuthentication {
  final public func validToken(backend: TicketmasterAuthentication.TMAuthentication.BackendService? = nil, showLoginIfNeeded: Swift.Bool = true, loginProperties: [Swift.String : Swift.String]? = nil, presentationViewController: UIKit.UIViewController? = nil, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, callSource: Swift.String? = nil, success: @escaping (_ authToken: TicketmasterAuthentication.TMAuthToken) -> Swift.Void, aborted: @escaping (_ oldAuthToken: TicketmasterAuthentication.TMAuthToken?, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService) -> Swift.Void, failure: @escaping (_ oldAuthToken: TicketmasterAuthentication.TMAuthToken?, _ error: any Swift.Error, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Void)
}
public struct TMAuthToken : Swift.Codable, Swift.Hashable {
  public let backend: TicketmasterAuthentication.TMAuthentication.BackendService
  public let exchangeSourceBackend: TicketmasterAuthentication.TMAuthentication.BackendService?
  public let externalToken: Swift.String?
  public let accessToken: Swift.String
  public let tokenType: Swift.String?
  public let scope: Swift.String?
  public let expireDate: Foundation.Date
  public let idToken: Swift.String?
  public let hmacID: Swift.String?
  public let accountManagerHmacID: Swift.String?
  public let doNotSellFlag: Swift.Bool?
  public init(backend: TicketmasterAuthentication.TMAuthentication.BackendService, exchangeSourceBackend: TicketmasterAuthentication.TMAuthentication.BackendService?, externalToken: Swift.String?, accessToken: Swift.String, tokenType: Swift.String?, scope: Swift.String?, expireDate: Foundation.Date, idToken: Swift.String?, hmacID: Swift.String?, accountManagerHmacID: Swift.String?, doNotSellFlag: Swift.Bool?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TicketmasterAuthentication.TMAuthToken, b: TicketmasterAuthentication.TMAuthToken) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension TicketmasterAuthentication.TMAuthentication {
  public struct LoginURLOAuth {
    public let url: Foundation.URL
    public let callbackURLScheme: Swift.String
    public let codeVerifier: Swift.String?
    public let state: Swift.String?
    public init(url: Foundation.URL, callbackURLScheme: Swift.String, codeVerifier: Swift.String?, state: Swift.String?)
  }
}
extension TicketmasterAuthentication.TMApigeeConfig.SportXR {
  public var cookieDomainFromCookieName: Swift.String? {
    get
  }
  public var cookieDomainFromTeamDomain: Swift.String? {
    get
  }
}
extension TicketmasterAuthentication.TMAuthentication {
  final public func validateMFAToken(backend: TicketmasterAuthentication.TMAuthentication.BackendService? = nil, mfaProperties: [Swift.String : Any]? = nil, presentationViewController: UIKit.UIViewController? = nil, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, callSource: Swift.String? = nil, success: @escaping (_ mfaToken: TicketmasterAuthentication.TMMFAToken) -> Swift.Void, aborted: @escaping (_ backend: TicketmasterAuthentication.TMAuthentication.BackendService) -> Swift.Void, failure: @escaping (_ error: any Swift.Error, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Void)
}
extension TicketmasterAuthentication.TMApigeeConfig {
  public init(jsonDictionary: TicketmasterFoundation.JSONDictionary, originalData: Foundation.Data, tmxSettings: TicketmasterAuthentication.TMAuthentication.TMXSettings, forcedJSONDictionary: TicketmasterFoundation.JSONDictionary?, acquiredDate: Foundation.Date? = nil)
}
extension TicketmasterAuthentication.TMAuthentication {
  final public func hasToken(backend: TicketmasterAuthentication.TMAuthentication.BackendService? = nil) -> Swift.Bool
  final public func hasUnexpiredToken(backend: TicketmasterAuthentication.TMAuthentication.BackendService? = nil) -> Swift.Bool
  @available(*, deprecated, message: "Call hasUnexpiredToken(backend:...) instead. Because tokens can be invalidated at any time, this method is meaningless.")
  final public func hasValidatedToken(backend: TicketmasterAuthentication.TMAuthentication.BackendService? = nil) -> Swift.Bool
}
extension TicketmasterAuthentication.TMAuthentication {
  public enum InfoToEncode {
    case string(Swift.String?)
    case data(Foundation.Data)
  }
  final public func boundDeviceIdSignature(backend: TicketmasterAuthentication.TMAuthentication.BackendService?, callSource: Swift.String, infoToEncode: TicketmasterAuthentication.TMAuthentication.InfoToEncode, success: @escaping (_ deviceKey: TicketmasterAuthentication.TMDeviceKey) -> Swift.Void, failure: @escaping (_ error: any Swift.Error, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Void)
  final public func bindNewDeviceKey(backend: TicketmasterAuthentication.TMAuthentication.BackendService? = nil, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, callSource: Swift.String, success: @escaping (_ remainingKeys: Swift.Int?) -> Swift.Void, failure: @escaping (_ error: any Swift.Error, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Void)
}
extension TicketmasterAuthentication.TMAuthentication {
  public struct AuthNotification {
    public static let serviceConfigurationStarted: Foundation.Notification.Name
    public static let serviceConfigured: Foundation.Notification.Name
    public static let serviceConfigurationCompleted: Foundation.Notification.Name
    public static let loginStarted: Foundation.Notification.Name
    public static let loginExchanging: Foundation.Notification.Name
    public static let loginPresented: Foundation.Notification.Name
    public static let loggedIn: Foundation.Notification.Name
    public static let loginAborted: Foundation.Notification.Name
    public static let loginFailed: Foundation.Notification.Name
    public static let loginLinkAccountPresented: Foundation.Notification.Name
    public static let loginCompleted: Foundation.Notification.Name
    public static let tokenRefreshed: Foundation.Notification.Name
    public static let logoutStarted: Foundation.Notification.Name
    public static let loggedOut: Foundation.Notification.Name
    public static let logoutCompleted: Foundation.Notification.Name
    public static let backendKey: Swift.String
    public static let errorKey: Swift.String
    public static var allNotifications: [Foundation.Notification.Name] {
      get
    }
    public static func state(notificationName: Foundation.Notification.Name) -> TicketmasterAuthentication.TMAuthentication.ServiceState?
    public static func error(notification: Foundation.Notification) -> (any Swift.Error)?
    public static func backend(notification: Foundation.Notification) -> TicketmasterAuthentication.TMAuthentication.BackendService?
  }
}
public protocol TMEncodableAssertion {
  func base64URLEncodedString() -> Swift.String?
}
public protocol TMAssertion : Swift.Decodable, Swift.Encodable, Swift.Hashable, TicketmasterAuthentication.TMEncodableAssertion {
  var format: Swift.UInt8 { get set }
  var authenticatorData: Foundation.Data? { get set }
  var clientDataJSONHash: Foundation.Data? { get set }
  var signature: Foundation.Data { get set }
  init(format: Swift.UInt8, signature: Foundation.Data)
  init(format: Swift.UInt8, authenticatorData: Foundation.Data, clientDataJSONHash: Foundation.Data, signature: Foundation.Data)
}
public struct AppAttestAssertion : TicketmasterAuthentication.TMAssertion {
  public var format: Swift.UInt8
  public var authenticatorData: Foundation.Data?
  public var clientDataJSONHash: Foundation.Data?
  public var signature: Foundation.Data
  public init(authenticatorData: Foundation.Data, clientDataJSONHash: Foundation.Data, signature: Foundation.Data)
  public static func == (a: TicketmasterAuthentication.AppAttestAssertion, b: TicketmasterAuthentication.AppAttestAssertion) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension TicketmasterAuthentication.TMAssertion {
  public init(format: Swift.UInt8, signature: Foundation.Data)
  public init(format: Swift.UInt8, authenticatorData: Foundation.Data, clientDataJSONHash: Foundation.Data, signature: Foundation.Data)
}
extension TicketmasterAuthentication.TMAssertion {
  public func base64URLEncodedString() -> Swift.String?
}
extension TicketmasterAuthentication.TMAuthentication {
  final public func login(backend: TicketmasterAuthentication.TMAuthentication.BackendService? = nil, externalToken: Swift.String? = nil, loginProperties: [Swift.String : Swift.String]? = nil, presentationViewController: UIKit.UIViewController? = nil, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, callSource: Swift.String? = nil, success: @escaping (_ authToken: TicketmasterAuthentication.TMAuthToken) -> Swift.Void, aborted: @escaping (_ oldAuthToken: TicketmasterAuthentication.TMAuthToken?, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService) -> Swift.Void, failure: @escaping (_ oldAuthToken: TicketmasterAuthentication.TMAuthToken?, _ error: any Swift.Error, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Void)
}
extension TicketmasterAuthentication.TMAuthentication {
  final public func customConfigure(brandedServiceSettingArray: [TicketmasterAuthentication.TMAuthentication.BrandedServiceSettings], fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, success: @escaping (_ backendsConfigured: [TicketmasterAuthentication.TMAuthentication.BackendService]) -> Swift.Void, failure: @escaping (_ backendsConfigured: [TicketmasterAuthentication.TMAuthentication.BackendService], _ error: any Swift.Error) -> Swift.Void)
  final public func customConfigure(brandedServiceSettings: TicketmasterAuthentication.TMAuthentication.BrandedServiceSettings, apigeeConfig: TicketmasterAuthentication.TMApigeeConfig? = nil, sourceFilter: TicketmasterAuthentication.TMAuthentication.AuthSource? = nil, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, success: @escaping (_ backendsConfigured: [TicketmasterAuthentication.TMAuthentication.BackendService]) -> Swift.Void, failure: @escaping (_ backendsConfigured: [TicketmasterAuthentication.TMAuthentication.BackendService], _ error: any Swift.Error) -> Swift.Void)
}
extension TicketmasterAuthentication.TMAuthentication {
  public struct AuthError {
    public static let domain: Swift.String
    public static let unknown: Foundation.NSError
    public static let operationCanceled: Foundation.NSError
    public static let apigeeConfigurationNotFound: Foundation.NSError
    public static let configurationForBackendNotFound: Foundation.NSError
    public static let serviceConfigurationsNotDefined: Foundation.NSError
    public static let serviceConfigurationNotFound: Foundation.NSError
    public static let serviceConfigurationNilNotAllowed: Foundation.NSError
    public static let apigeeConfigurationNotCached: Foundation.NSError
    public static let notSupportedByBackendService: Foundation.NSError
    public static let unknownJSONFormat: Foundation.NSError
    public static let exchangeMissingAuthTokenForRequestedService: Foundation.NSError
    public static let userNotLoggedIn: Foundation.NSError
    public static let relatedAccountNotFound: Foundation.NSError
    public static let memberInfoNotCached: Foundation.NSError
    public static let authTokenServiceMismatch: Foundation.NSError
    public static let userRefreshedAsDifferentUser: Foundation.NSError
    public static let authTokenSourceServiceNotFound: Foundation.NSError
    public static let missingEncryptedDeviceId: Foundation.NSError
    public static let mfaWidgetUnknown: Foundation.NSError
    public static let mfaWidgetFailedLoad: Foundation.NSError
    public static let mfaWidgetMaxAttempts: Foundation.NSError
    public static let mfaWidgetUnauthorizedUser: Foundation.NSError
    public static let mfaTokenNotCached: Foundation.NSError
    public static let externalTokenExchangeDisabled: Foundation.NSError
    public static let externalTokenAlreadyLoggedIn: Foundation.NSError
    public static let externalTokenProviderNil: Foundation.NSError
    public static let externalTokenRefreshRequiresUI: Foundation.NSError
    public static let deviceNotBound: Foundation.NSError
    public static let signatureDataInvalid: Foundation.NSError
    public static let unableToSignDeviceKeyId: Foundation.NSError
    public static let appAttestServiceUnavailable: Foundation.NSError
    public static let unableToGenerateAttestationKeyId: Foundation.NSError
    public static let unableToDecodeAssertion: Foundation.NSError
    public static let deviceLimitReached: Foundation.NSError
    public static let appNotAuthorized: Foundation.NSError
    public static let assertionDataInvalid: Foundation.NSError
  }
}
public struct TMDeviceKey : Swift.Codable, Swift.Hashable {
  public let keyId: Foundation.Data
  public let assertion: TicketmasterAuthentication.AppAttestAssertion
  public init(keyId: Foundation.Data, assertion: TicketmasterAuthentication.AppAttestAssertion)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TicketmasterAuthentication.TMDeviceKey, b: TicketmasterAuthentication.TMDeviceKey) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension TicketmasterAuthentication.TMAuthentication {
  final public func memberInfo(backend: TicketmasterAuthentication.TMAuthentication.BackendService? = nil, relatedAccount: TicketmasterAuthentication.TMMemberInfo.RelatedAccount? = nil, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, callSource: Swift.String? = nil, success: @escaping (_ memberInfo: TicketmasterAuthentication.TMMemberInfo) -> Swift.Void, failure: @escaping (_ oldMemberInfo: TicketmasterAuthentication.TMMemberInfo?, _ error: any Swift.Error, _ backend: TicketmasterAuthentication.TMAuthentication.BackendService?) -> Swift.Void)
}
extension TicketmasterAuthentication.TMAuthentication {
  public struct BackendService : Swift.Codable, Swift.Hashable {
    public let source: TicketmasterAuthentication.TMAuthentication.AuthSource
    public let region: TicketmasterAuthentication.TMAuthentication.TMXDeploymentRegion?
    public let environment: TicketmasterAuthentication.TMAuthentication.TMXDeploymentEnvironment
    public let instanceID: Swift.String?
    public static let HostModernAccounts: TicketmasterAuthentication.TMAuthentication.BackendService
    public static let HostFederated: TicketmasterAuthentication.TMAuthentication.BackendService
    public static let TeamModernAccounts: TicketmasterAuthentication.TMAuthentication.BackendService
    public static let TeamFederated: TicketmasterAuthentication.TMAuthentication.BackendService
    public static let MFXModernAccounts: TicketmasterAuthentication.TMAuthentication.BackendService
    public static let SportXR: TicketmasterAuthentication.TMAuthentication.BackendService
    public init(source: TicketmasterAuthentication.TMAuthentication.AuthSource, region: TicketmasterAuthentication.TMAuthentication.TMXDeploymentRegion? = nil, environment: TicketmasterAuthentication.TMAuthentication.TMXDeploymentEnvironment? = .Production, instanceID: Swift.String? = nil)
    public var keyName: Swift.String? {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMAuthentication.BackendService, b: TicketmasterAuthentication.TMAuthentication.BackendService) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum AuthSource : Swift.String, Swift.Codable, Swift.Hashable, Swift.CaseIterable {
    case modernAccountsHost
    case modernAccountsTeam
    case modernAccountsMicroflex
    case federatedHost
    case federatedTeam
    case sportXR
    public var keyName: Swift.String {
      get
    }
    public var publicName: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias AllCases = [TicketmasterAuthentication.TMAuthentication.AuthSource]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [TicketmasterAuthentication.TMAuthentication.AuthSource] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension TicketmasterAuthentication.TMApigeeConfig.Base {
  public var validLocale: Foundation.Locale {
    get
  }
  public var validLocaleAcceptLanguageCode: Swift.String {
    get
  }
  public var validLocaleCountryCode: Swift.String {
    get
  }
  public var validLocaleLanguageCode: Swift.String {
    get
  }
  public var marketDomain: TicketmasterFoundation.MarketDomain {
    get
  }
}
extension TicketmasterAuthentication.TMApigeeConfig.Base {
  public var isEnglishLocale: Swift.Bool {
    get
  }
  public var isFrenchLocale: Swift.Bool {
    get
  }
  public var isItalianLocale: Swift.Bool {
    get
  }
  public var isGermanLocale: Swift.Bool {
    get
  }
  public var isSpanishLocale: Swift.Bool {
    get
  }
  public var isSwedishLocale: Swift.Bool {
    get
  }
  public var isCatalanLocale: Swift.Bool {
    get
  }
  public var isPolishLocale: Swift.Bool {
    get
  }
  public var isNorwegianLocale: Swift.Bool {
    get
  }
  public var isFinnishLocale: Swift.Bool {
    get
  }
  public var isDutchLocale: Swift.Bool {
    get
  }
  public var isCzechLocale: Swift.Bool {
    get
  }
  public var isDanishLocale: Swift.Bool {
    get
  }
}
public struct TMMemberInfo : Swift.Codable, Swift.Hashable {
  public let backend: TicketmasterAuthentication.TMAuthentication.BackendService
  public let localID: Swift.String?
  public let globalID: Swift.String?
  public let hmacID: Swift.String?
  public let doNotSellFlag: Swift.Bool?
  public let firstName: Swift.String?
  public let lastName: Swift.String?
  public let email: Swift.String?
  public let phone: Swift.String?
  public let postalCode: Swift.String?
  public let language: Swift.String?
  public let country: Swift.String?
  public let relatedAccounts: [TicketmasterAuthentication.TMMemberInfo.RelatedAccount]?
  public let termsOfUse: TicketmasterAuthentication.TMMemberInfo.TermsOfUse?
  public let acquiredDate: Foundation.Date
  public struct RelatedAccount : Swift.Codable, Swift.Hashable {
    public let localID: Swift.String
    public let nickname: Swift.String
    public let isDefault: Swift.Bool
    public let isCurrent: Swift.Bool
    public init(localID: Swift.String, nickname: Swift.String, isDefault: Swift.Bool, isCurrent: Swift.Bool)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMMemberInfo.RelatedAccount, b: TicketmasterAuthentication.TMMemberInfo.RelatedAccount) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct TermsOfUse : Swift.Codable, Swift.Hashable {
    public let version: Swift.String?
    public let acceptanceRequired: Swift.Bool
    public let text: Swift.String?
    public init(version: Swift.String?, acceptanceRequired: Swift.Bool, text: Swift.String?)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMMemberInfo.TermsOfUse, b: TicketmasterAuthentication.TMMemberInfo.TermsOfUse) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public init(backend: TicketmasterAuthentication.TMAuthentication.BackendService, localID: Swift.String?, globalID: Swift.String?, hmacID: Swift.String?, doNotSellFlag: Swift.Bool?, firstName: Swift.String?, lastName: Swift.String?, email: Swift.String?, phone: Swift.String?, postalCode: Swift.String?, language: Swift.String?, country: Swift.String?, relatedAccounts: [TicketmasterAuthentication.TMMemberInfo.RelatedAccount]?, termsOfUse: TicketmasterAuthentication.TMMemberInfo.TermsOfUse?, acquiredDate: Foundation.Date)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TicketmasterAuthentication.TMMemberInfo, b: TicketmasterAuthentication.TMMemberInfo) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension TicketmasterAuthentication.TMMemberInfo {
  public func verify(relatedAccount: TicketmasterAuthentication.TMMemberInfo.RelatedAccount?) -> Swift.Bool
  public func localID(relatedAccount: TicketmasterAuthentication.TMMemberInfo.RelatedAccount?) -> Swift.String?
  public func relatedAccount(localID: Swift.String) -> TicketmasterAuthentication.TMMemberInfo.RelatedAccount?
}
extension TicketmasterAuthentication.TMAuthentication {
  public struct TMXSettings : Swift.Codable, Swift.Hashable, Swift.Equatable {
    public let apiKey: Swift.String
    public let region: TicketmasterAuthentication.TMAuthentication.TMXDeploymentRegion
    public let environment: TicketmasterAuthentication.TMAuthentication.TMXDeploymentEnvironment
    public var keyName: Swift.String {
      get
    }
    public init(apiKey: Swift.String, region: TicketmasterAuthentication.TMAuthentication.TMXDeploymentRegion = .US, environment: TicketmasterAuthentication.TMAuthentication.TMXDeploymentEnvironment = .Production)
    public static func == (lhs: TicketmasterAuthentication.TMAuthentication.TMXSettings, rhs: TicketmasterAuthentication.TMAuthentication.TMXSettings) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum TMXDeploymentRegion : Swift.String, Swift.Codable, Swift.Hashable, Swift.CaseIterable {
    case US
    case UK
    public var keyName: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias AllCases = [TicketmasterAuthentication.TMAuthentication.TMXDeploymentRegion]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [TicketmasterAuthentication.TMAuthentication.TMXDeploymentRegion] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @frozen public enum TMXDeploymentEnvironment : Swift.String, Swift.Codable, Swift.Hashable, Swift.CaseIterable {
    case Production
    case Staging
    case StagingNew
    case PreProduction
    case QA
    public var keyName: Swift.String {
      get
    }
    public var connectionEnvironment: TicketmasterFoundation.ConnectionEnvironment {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias AllCases = [TicketmasterAuthentication.TMAuthentication.TMXDeploymentEnvironment]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [TicketmasterAuthentication.TMAuthentication.TMXDeploymentEnvironment] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ServiceState : Swift.String, Swift.Codable, Swift.Hashable, Swift.CaseIterable {
    case serviceConfigurationStarted
    case serviceConfigured
    case serviceConfigurationCompleted
    case loginStarted
    case loginExchanging
    case loginPresented
    case loggedIn
    case loginAborted
    case loginFailed
    case loginLinkAccountPresented
    case loginCompleted
    case tokenRefreshed
    case logoutStarted
    case loggedOut
    case logoutCompleted
    public var notificationName: Foundation.Notification.Name {
      get
    }
    public static func state(forNotification notification: Foundation.Notification) -> TicketmasterAuthentication.TMAuthentication.ServiceState?
    public init?(rawValue: Swift.String)
    public typealias AllCases = [TicketmasterAuthentication.TMAuthentication.ServiceState]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [TicketmasterAuthentication.TMAuthentication.ServiceState] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public enum FetchRule : Swift.String, Swift.Codable, Swift.Hashable, Swift.Equatable {
    case cachedOnly
    case fetchIfEmpty
    case fetchIfEmptyOrOld
    case forceFetch
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
#if compiler(>=5.3) && $RetroactiveAttribute
extension UIKit.UIViewController : @retroactive AuthenticationServices.ASWebAuthenticationPresentationContextProviding {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func presentationAnchor(for session: AuthenticationServices.ASWebAuthenticationSession) -> AuthenticationServices.ASPresentationAnchor
}
#else
extension UIKit.UIViewController : AuthenticationServices.ASWebAuthenticationPresentationContextProviding {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func presentationAnchor(for session: AuthenticationServices.ASWebAuthenticationSession) -> AuthenticationServices.ASPresentationAnchor
}
#endif
extension TicketmasterAuthentication.TMAuthentication {
  final public func loginSelectionPage(backend: TicketmasterAuthentication.TMAuthentication.BackendService? = nil, loginProperties: [Swift.String : Swift.String]? = nil, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, callSource: Swift.String? = nil) -> UIKit.UIViewController?
}
public struct TMApigeeConfig : Swift.Codable, Swift.Hashable {
  public let tmxSettings: TicketmasterAuthentication.TMAuthentication.TMXSettings
  public let acquiredDate: Foundation.Date
  public let base: TicketmasterAuthentication.TMApigeeConfig.Base
  public let modernAccounts: TicketmasterAuthentication.TMApigeeConfig.ModernAccounts?
  public let federated: TicketmasterAuthentication.TMApigeeConfig.Federated?
  public let sportXR: TicketmasterAuthentication.TMApigeeConfig.SportXR?
  public let analytics: TicketmasterAuthentication.TMApigeeConfig.Analytics
  public let fanEducation: TicketmasterAuthentication.TMApigeeConfig.FanEducation
  public let gameday: TicketmasterAuthentication.TMApigeeConfig.GameDay
  public let launchAction: TicketmasterAuthentication.TMApigeeConfig.LaunchAction?
  public let forcedLogout: TicketmasterAuthentication.TMApigeeConfig.ForcedLogout?
  public let originalData: Foundation.Data
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TicketmasterAuthentication.TMApigeeConfig, b: TicketmasterAuthentication.TMApigeeConfig) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension TicketmasterAuthentication.TMApigeeConfig {
  public struct Base : Swift.Codable, Swift.Hashable {
    public let uwdKey: Swift.String?
    public let localeString: Swift.String
    public let quickLoginDisabled: Swift.Bool
    public let venueNextDisabled: Swift.Bool
    public let externalModulesEnabled: Swift.Bool
    public let accountSwitchEnabled: Swift.Bool
    public let barcodeV2Enabled: Swift.Bool
    public let barcodeV2HowToURL: Foundation.URL?
    public let fanWalletEnabled: Swift.Bool
    public let prefetchTicketsEnabled: Swift.Bool
    public let timePool: Swift.String?
    public let eventsThrottling: Swift.String?
    public let ticketsThrottling: Swift.String?
    public let passesThrottling: Swift.String?
    public let venueIdFilter: [Swift.String]?
    public let attractionIdFilter: [Swift.String]?
    public let logoURL: Foundation.URL?
    public let assignFlowEnabled: Swift.Bool
    public let assignFlowLearnMoreURLs: [Swift.String : Foundation.URL]?
    public let useICCPFetchTickets: Swift.Bool
    public let venueSuppressionRules: [TicketmasterAuthentication.TMApigeeConfig.VenueSuppressionRule]?
    public let venueUnsuppressRuleIdentifier: Swift.String?
    public let upsellAddOnsEnabled: Swift.Bool
    public let forceEventsDesignVersion: Swift.String?
    public let forceTicketsDesignVersion: Swift.String?
    public let isSellButtonHidden: Swift.Bool
    public let sellManageListingsOverrideURL: Foundation.URL?
    public let cmsModulesEnabled: Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMApigeeConfig.Base, b: TicketmasterAuthentication.TMApigeeConfig.Base) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ModernAccounts : Swift.Codable, Swift.Hashable {
    public let host: TicketmasterAuthentication.TMApigeeConfig.ModernAccounts.Configuration?
    public let team: TicketmasterAuthentication.TMApigeeConfig.ModernAccounts.Configuration?
    public let mfx: TicketmasterAuthentication.TMApigeeConfig.ModernAccounts.Configuration?
    public struct Configuration : Swift.Codable, Swift.Hashable {
      public let enabled: Swift.Bool
      public let clientId: Swift.String
      public let mfaEnabled: Swift.Bool
      public let mfaClientId: Swift.String?
      public let scope: Swift.String?
      public let siteToken: Swift.String?
      public let redirectScheme: Swift.String?
      public let visualPresets: Swift.String?
      public let integratorId: Swift.String?
      public let placementId: Swift.String?
      public let prefersEphemeralWebBrowserSession: Swift.Bool
      public let systemExchangeClientIDs: [Swift.String]?
      public let allowTeamToHostSystemExchange: Swift.Bool
      public let tmxWillCreateExternalGuestUser: Swift.Bool
      public let forceWebTransfer: Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: TicketmasterAuthentication.TMApigeeConfig.ModernAccounts.Configuration, b: TicketmasterAuthentication.TMApigeeConfig.ModernAccounts.Configuration) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMApigeeConfig.ModernAccounts, b: TicketmasterAuthentication.TMApigeeConfig.ModernAccounts) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Federated : Swift.Codable, Swift.Hashable {
    public let host: TicketmasterAuthentication.TMApigeeConfig.Federated.Host?
    public let team: TicketmasterAuthentication.TMApigeeConfig.Federated.Team?
    public struct Host : Swift.Codable, Swift.Hashable {
      public let consumerKey: Swift.String
      public let consumerSecret: Swift.String
      public let redirectURL: Foundation.URL
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: TicketmasterAuthentication.TMApigeeConfig.Federated.Host, b: TicketmasterAuthentication.TMApigeeConfig.Federated.Host) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct Team : Swift.Codable, Swift.Hashable {
      public let consumerKey: Swift.String
      public let consumerSecret: Swift.String
      public let redirectURL: Foundation.URL
      public let apiKey: Swift.String
      public var clientName: Swift.String {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: TicketmasterAuthentication.TMApigeeConfig.Federated.Team, b: TicketmasterAuthentication.TMApigeeConfig.Federated.Team) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMApigeeConfig.Federated, b: TicketmasterAuthentication.TMApigeeConfig.Federated) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct SportXR : Swift.Codable, Swift.Hashable {
    public let consumerKey: Swift.String
    public let redirectScheme: Swift.String
    public let tenantId: Swift.String
    public let scope: Swift.String
    public let teamDomain: Swift.String?
    public let teamPathName: Swift.String?
    public let cookieName: Swift.String?
    public let cookieDomains: [Swift.String]?
    public let prefersEphemeralWebBrowserSession: Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMApigeeConfig.SportXR, b: TicketmasterAuthentication.TMApigeeConfig.SportXR) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Analytics : Swift.Codable, Swift.Hashable {
    public let enabled: Swift.Bool
    public let batchSize: Swift.Int
    public let batchTime: Swift.Int
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMApigeeConfig.Analytics, b: TicketmasterAuthentication.TMApigeeConfig.Analytics) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct FanEducation : Swift.Codable, Swift.Hashable {
    public let tintColorString: Swift.String?
    public var tintColor: UIKit.UIColor? {
      get
    }
    public let backgroundColorString: Swift.String?
    public var backgroundColor: UIKit.UIColor? {
      get
    }
    public let transferTipEnabled: Swift.Bool
    public let resaleTipEnabled: Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMApigeeConfig.FanEducation, b: TicketmasterAuthentication.TMApigeeConfig.FanEducation) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct GameDay : Swift.Codable, Swift.Hashable {
    public let enabled: Swift.Bool
    public let redirectURL: Foundation.URL?
    public var defaultUrl: Foundation.URL? {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMApigeeConfig.GameDay, b: TicketmasterAuthentication.TMApigeeConfig.GameDay) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct LaunchAction : Swift.Codable, Swift.Hashable {
    public let typeOfLaunchActionUrlViewer: Swift.String?
    public let webviewURL: Foundation.URL?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMApigeeConfig.LaunchAction, b: TicketmasterAuthentication.TMApigeeConfig.LaunchAction) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct VenueSuppressionRule : Swift.Codable, Swift.Hashable {
    public let identifier: Swift.String
    public let appName: Swift.String?
    public let appURL: Foundation.URL?
    public let venueDiscoveryIds: [Swift.String]?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMApigeeConfig.VenueSuppressionRule, b: TicketmasterAuthentication.TMApigeeConfig.VenueSuppressionRule) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ForcedLogout : Swift.Codable, Swift.Hashable {
    public let instance: Swift.Double
    public let sdkVersion: Swift.String?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMApigeeConfig.ForcedLogout, b: TicketmasterAuthentication.TMApigeeConfig.ForcedLogout) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension TicketmasterAuthentication.TMAuthentication {
  final public func logout(backend: TicketmasterAuthentication.TMAuthentication.BackendService? = nil, fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, callSource: Swift.String? = nil, completion: @escaping (_ backends: [TicketmasterAuthentication.TMAuthentication.BackendService]?) -> Swift.Void)
  final public func logoutAll(fetchRule: TicketmasterAuthentication.TMAuthentication.FetchRule? = .fetchIfEmptyOrOld, callSource: Swift.String? = nil, completion: @escaping (_ backends: [TicketmasterAuthentication.TMAuthentication.BackendService]?) -> Swift.Void)
  final public func clearAllCachedData(callSource: Swift.String? = nil, completion: @escaping () -> Swift.Void)
}
extension TicketmasterAuthentication.TMAuthentication {
  public struct BrandedServiceSettings : Swift.Codable, Swift.Hashable {
    public let tmxSettings: TicketmasterAuthentication.TMAuthentication.TMXSettings
    public let branding: TicketmasterAuthentication.TMAuthentication.Branding
    public init(tmxSettings: TicketmasterAuthentication.TMAuthentication.TMXSettings, branding: TicketmasterAuthentication.TMAuthentication.Branding? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMAuthentication.BrandedServiceSettings, b: TicketmasterAuthentication.TMAuthentication.BrandedServiceSettings) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Branding : Swift.Codable, Swift.Hashable {
    public let displayName: Swift.String?
    public let backgroundColor: UIKit.UIColor
    public let foregroundColor: UIKit.UIColor
    public let theme: TicketmasterAuthentication.TMAuthentication.ColorTheme
    public let enableTMBrandingColorOverride: Swift.Bool
    public let eventNameType: TicketmasterAuthentication.TMAuthentication.EventNameType
    public init(displayName: Swift.String? = nil, backgroundColor: UIKit.UIColor? = nil, foregroundColor: UIKit.UIColor? = nil, theme: TicketmasterAuthentication.TMAuthentication.ColorTheme? = .light, enableTMBrandingColorOverride: Swift.Bool? = false, eventNameType: TicketmasterAuthentication.TMAuthentication.EventNameType? = .event)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterAuthentication.TMAuthentication.Branding, b: TicketmasterAuthentication.TMAuthentication.Branding) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  @frozen public enum ColorTheme : Swift.String, Swift.Codable, Swift.Hashable, Swift.CaseIterable {
    case light
    case dark
    public var color: UIKit.UIColor {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias AllCases = [TicketmasterAuthentication.TMAuthentication.ColorTheme]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [TicketmasterAuthentication.TMAuthentication.ColorTheme] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public enum EventNameType : Swift.String, Swift.Codable, Swift.Hashable, Swift.CaseIterable {
    case event
    case concert
    case show
    case game
    case match
    public init?(rawValue: Swift.String)
    public typealias AllCases = [TicketmasterAuthentication.TMAuthentication.EventNameType]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [TicketmasterAuthentication.TMAuthentication.EventNameType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
@objc @_inheritsConvenienceInitializers final public class TMAuthentication : ObjectiveC.NSObject, TicketmasterAuthentication.TMAuthenticationProvider, TicketmasterAuthentication.TMApigeeConfigurationProvider, TicketmasterAuthentication.TMDeviceBindingProvider {
  public static let shared: TicketmasterAuthentication.TMAuthentication
  final public var version: Swift.String {
    get
  }
  final public var sdkBuildInfo: TicketmasterFoundation.JSONDictionary? {
    get
  }
  final public var useCombinedLogin: Swift.Bool
  final public var forceEphemeralWebBrowserSession: Swift.Bool?
  final public var disableSystemExchangeDuringLogin: Swift.Bool
  final public var useBrandedNavigationBar: Swift.Bool
  @available(*, deprecated, message: "Call login(backend:...) to present login directly, skipping the login page entirely")
  final public var autoPresentLoginPrompt: Swift.Bool
  weak final public var delegate: (any TicketmasterAuthentication.TMAuthenticationDelegate)?
  weak final public var externalTokenProviderDelegate: (any TicketmasterAuthentication.TMAuthenticationExternalTokenProvider)?
  final public func registerStateChanged(block: @escaping (_ backend: TicketmasterAuthentication.TMAuthentication.BackendService?, _ state: TicketmasterAuthentication.TMAuthentication.ServiceState, _ error: (any Swift.Error)?) -> Swift.Void)
  final public func clearAllStateChangedBlocks()
  final public var internalTestingKeys: [Swift.String : Any] {
    get
    set
  }
  @objc override dynamic public init()
  @objc deinit
}
public protocol TMAuthenticationDelegate : AnyObject {
  func onStateChanged(backend: TicketmasterAuthentication.TMAuthentication.BackendService?, state: TicketmasterAuthentication.TMAuthentication.ServiceState, error: (any Swift.Error)?)
}
public struct TMMFAToken : Swift.Codable, Swift.Hashable {
  public let backend: TicketmasterAuthentication.TMAuthentication.BackendService
  public let deviceVerifiedToken: Swift.String
  public let encryptedDeviceID: Swift.String
  public init(backend: TicketmasterAuthentication.TMAuthentication.BackendService, deviceVerifiedToken: Swift.String, encryptedDeviceID: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TicketmasterAuthentication.TMMFAToken, b: TicketmasterAuthentication.TMMFAToken) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension TicketmasterAuthentication.TMAuthentication.AuthSource : Swift.RawRepresentable {}
extension TicketmasterAuthentication.TMAuthentication.TMXDeploymentRegion : Swift.RawRepresentable {}
extension TicketmasterAuthentication.TMAuthentication.TMXDeploymentEnvironment : Swift.RawRepresentable {}
extension TicketmasterAuthentication.TMAuthentication.TMXDeploymentEnvironment : Swift.Sendable {}
extension TicketmasterAuthentication.TMAuthentication.TMXDeploymentEnvironment : Swift.BitwiseCopyable {}
extension TicketmasterAuthentication.TMAuthentication.ServiceState : Swift.RawRepresentable {}
extension TicketmasterAuthentication.TMAuthentication.FetchRule : Swift.RawRepresentable {}
extension TicketmasterAuthentication.TMAuthentication.ColorTheme : Swift.RawRepresentable {}
extension TicketmasterAuthentication.TMAuthentication.ColorTheme : Swift.Sendable {}
extension TicketmasterAuthentication.TMAuthentication.ColorTheme : Swift.BitwiseCopyable {}
extension TicketmasterAuthentication.TMAuthentication.EventNameType : Swift.RawRepresentable {}
