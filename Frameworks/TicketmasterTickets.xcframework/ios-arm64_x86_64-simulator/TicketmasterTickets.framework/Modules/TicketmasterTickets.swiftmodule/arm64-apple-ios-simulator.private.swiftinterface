// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios16.6-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name TicketmasterTickets
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import AVFoundation
import AuthenticationServices
import Combine
import Contacts
import ContactsUI
import CoreImage
import CoreLocation
import Darwin
import DeveloperToolsSupport
import EventKit
import Foundation
import MapKit
import MessageUI
import PassKit
import SafariServices
import Security
import Swift
import SwiftUI
import SystemConfiguration
import TicketmasterAuthentication
import TicketmasterFoundation
import TicketmasterSecureEntry
@_exported import TicketmasterTickets
import UIKit
import WebKit
import _Concurrency
import _PassKit_SwiftUI
import _StringProcessing
import _SwiftConcurrencyShims
public protocol TMTicketsOrderDelegate : AnyObject {
  func presentClientAppPage(deeplink: Swift.String)
  func handleNavBarButtonAction(page: TicketmasterTickets.TMTickets.Analytics.Page, screenTitleName: Swift.String?, event: TicketmasterTickets.TMPurchasedEvent?)
  func handleErrorPageCustomButton(title: Swift.String)
  func didUpdateEvents(events: [TicketmasterTickets.TMPurchasedEvent], fromCache: Swift.Bool)
  func didUpdateTickets(event: TicketmasterTickets.TMPurchasedEvent, fromCache: Swift.Bool)
  func didClearEventsTicketsCache(backend: TicketmasterAuthentication.TMAuthentication.BackendService)
}
extension UIKit.UITextView {
  @_Concurrency.MainActor @preconcurrency public func setTextWithLetterSpacing(text: Swift.String, letterSpacingPercentage: CoreFoundation.CGFloat, lineHeight: CoreFoundation.CGFloat = 0)
}
extension TicketmasterTickets.TMTickets {
  final public func configure(callSource: Swift.String? = nil, success: @escaping () -> Swift.Void, failure: @escaping (_ error: any Swift.Error) -> Swift.Void)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class TMTicketsModuleHeaderView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public static func build() -> TicketmasterTickets.TMTicketsModuleHeaderView
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension TicketmasterTickets.TMTicketsModuleHeaderView {
  @_Concurrency.MainActor @preconcurrency final public func playAVContent()
  @_Concurrency.MainActor @preconcurrency final public func pauseAVContent()
}
extension TicketmasterTickets.TMTicketsModuleHeaderView {
  @objc public class MapAnnotation : ObjectiveC.NSObject, MapKit.MKAnnotation {
    @objc final public let coordinate: CoreLocation.CLLocationCoordinate2D
    @objc final public let title: Swift.String?
    public init(coordinate: CoreLocation.CLLocationCoordinate2D, title: Swift.String?)
    @objc deinit
  }
}
extension UIKit.UILabel {
  @_Concurrency.MainActor @preconcurrency public func setTextWithLetterSpacing(text: Swift.String, letterSpacingPercentage: CoreFoundation.CGFloat, lineHeight: CoreFoundation.CGFloat = 0)
}
extension Swift.FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
     
     
     
  }
}
extension TicketmasterTickets.TMTickets {
  final public var brandingColorsOverride: TicketmasterTickets.TMTickets.BrandingColors? {
    get
    set
  }
  final public var brandingColorButtonOverride: Swift.Bool {
    get
    set
  }
  final public var brandingColorNavBarOverride: Swift.Bool {
    get
    set
  }
  final public var brandingTeamLogoImage: UIKit.UIImage? {
    get
    set
  }
  final public var brandingEventsPageBackgroundOverride: UIKit.UIColor? {
    get
    set
  }
  final public var userTrackingEnabled: Swift.Bool {
    get
    set
  }
  final public var useNewAccountsManager: Swift.Bool {
    get
    set
  }
}
extension TicketmasterTickets.TMTicketsModule {
  public static func moduleArray(jsonDict: TicketmasterFoundation.JSONDictionary, event: TicketmasterTickets.TMPurchasedEvent, completion: @escaping (_ modules: [TicketmasterTickets.TMTicketsModule]) -> Swift.Void)
}
public struct TMTicketsPrebuiltModule {
  public enum ModuleName : Swift.String, Swift.CaseIterable {
    case venueDirectionsViaAppleMaps
    case venueDirections
    case venueConcessions
    case hostSeatUpgrades
    case accountManagerSeatUpgrades
    case accountManagerMoreTicketActions
    case accountManagerInvoiceAction
    case promotionalModule
    case customModule
    public init?(rawValue: Swift.String)
    public typealias AllCases = [TicketmasterTickets.TMTicketsPrebuiltModule.ModuleName]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [TicketmasterTickets.TMTicketsPrebuiltModule.ModuleName] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ButtonCallbackName : Swift.String, Swift.CaseIterable {
    case moreTicketActions
    case seatUpgrades
    case hostSeatUpgrades
    case invoice
    case getDirections
    case rideShare
    case order
    case wallet
    public init?(rawValue: Swift.String)
    public typealias AllCases = [TicketmasterTickets.TMTicketsPrebuiltModule.ButtonCallbackName]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [TicketmasterTickets.TMTicketsPrebuiltModule.ButtonCallbackName] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public static func accountManagerSeatUpgrades(event: TicketmasterTickets.TMPurchasedEvent, headerOverride: TicketmasterTickets.TMTicketsPrebuiltModule.HeaderOverride? = nil, customIdentifier: Swift.String? = nil) -> TicketmasterTickets.TMTicketsModule?
  public static func hostSeatUpgrades(event: TicketmasterTickets.TMPurchasedEvent, headerOverride: TicketmasterTickets.TMTicketsPrebuiltModule.HeaderOverride? = nil, customIdentifier: Swift.String? = nil) -> TicketmasterTickets.TMTicketsModule?
  public static func accountManagerMoreTicketActions(event: TicketmasterTickets.TMPurchasedEvent, headerOverride: TicketmasterTickets.TMTicketsPrebuiltModule.HeaderOverride? = nil, customIdentifier: Swift.String? = nil) -> TicketmasterTickets.TMTicketsModule?
  public static func accountManagerInvoiceAction(event: TicketmasterTickets.TMPurchasedEvent, headerOverride: TicketmasterTickets.TMTicketsPrebuiltModule.HeaderOverride? = nil, customIdentifier: Swift.String? = nil) -> TicketmasterTickets.TMTicketsModule?
  public static func venueDirectionsViaAppleMaps(event: TicketmasterTickets.TMPurchasedEvent, headerOverride: TicketmasterTickets.TMTicketsPrebuiltModule.HeaderOverride? = nil, customIdentifier: Swift.String? = nil) -> TicketmasterTickets.TMTicketsModule?
  public static func venueConcessions(event: TicketmasterTickets.TMPurchasedEvent, headerOverride: TicketmasterTickets.TMTicketsPrebuiltModule.HeaderOverride? = nil, showWalletButton: Swift.Bool, customIdentifier: Swift.String? = nil) -> TicketmasterTickets.TMTicketsModule?
}
public struct TMPurchasedEventInfo : Swift.Codable, Swift.Hashable {
  public let identifier: Swift.String
  public let uniqueIdentifier: Swift.String?
  public let hostIdentifier: Swift.String?
  public let discoveryIdentifier: Swift.String?
  public let childEventIDs: [Swift.String]?
  public let relatedIdentifiers: [Swift.String]?
  public let name: Swift.String?
  public let eventDescription: Swift.String?
  public let imageInfo: TicketmasterTickets.TMPurchasedEventInfo.ImageInfo?
  public let url: Foundation.URL?
  public let code: Swift.String?
  public let typeName: Swift.String?
  public let status: Swift.String?
  public let color: Swift.String?
  public let dateInfo: TicketmasterTickets.TMPurchasedEventInfo.DateInfo?
  public let isPastEvent: Swift.Bool?
  @available(*, deprecated, message: "Use (eventSource == .host) for HOST events OR (eventSource == .archtics) for Archtics events instead")
  public let isHostEvent: Swift.Bool?
  public let isSeriesMaster: Swift.Bool?
  public let isSeriesChild: Swift.Bool?
  public let isArchticsEvent: Swift.Bool?
  @available(*, deprecated, message: "Use eventSource == .sportXR instead")
  public let isSportXREvent: Swift.Bool?
  @available(*, deprecated, message: "Use eventSource == .microflex instead")
  public let isMicroflexEvent: Swift.Bool?
  public let isThirdPartyResale: Swift.Bool?
  public let isStreaming: Swift.Bool?
  public let eventSource: TicketmasterTickets.TMPurchasedEventInfo.EventSource?
  public let promoterBranding: TicketmasterTickets.TMPurchasedEventInfo.PromoterBranding?
  public let healthCheck: TicketmasterTickets.TMPurchasedEventInfo.HealthCheck?
  public let venue: TicketmasterTickets.TMPurchasedEventInfo.Venue?
  public let attraction: TicketmasterTickets.TMPurchasedEventInfo.Attraction?
  public let hostOrderInfos: [TicketmasterTickets.TMPurchasedEventInfo.Order]?
  public let hostOrderIDs: [Swift.String]?
  public let encodedHostOrderIDs: [Swift.String]?
  public let orderStatus: Swift.String?
  public let isF2FExchangeEnabled: Swift.Bool?
  public let ticketManagement: TicketmasterTickets.TMPurchasedEventInfo.TicketManagement?
  public let isOrdersAPI: Swift.Bool?
  public let isGlobal: Swift.Bool?
  public let useTmtt: Swift.Bool?
  public let isRetEnabled: Swift.Bool?
  public let isLarge: Swift.Bool?
  public let assignEnabled: Swift.Bool?
  public let changeStatus: Swift.String?
  public struct ImageInfo : Swift.Codable, Swift.Hashable {
    public let identifier: Swift.String?
    public let name: Swift.String?
    public let url: Foundation.URL?
    public let height: CoreFoundation.CGFloat?
    public let width: CoreFoundation.CGFloat?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMPurchasedEventInfo.ImageInfo, b: TicketmasterTickets.TMPurchasedEventInfo.ImageInfo) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Venue : Swift.Codable, Swift.Hashable {
    public let identifier: Swift.String?
    public let name: Swift.String?
    public let timezone: Swift.String?
    public let address: TicketmasterTickets.TMPurchasedEventInfo.Venue.Address?
    public let geolocation: TicketmasterTickets.TMPurchasedEventInfo.Venue.Location?
    public struct Address : Swift.Codable, Swift.Hashable {
      public let line1: Swift.String?
      public let city: Swift.String?
      public let region: Swift.String?
      public let postalCode: Swift.String?
      public let country: Swift.String?
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: TicketmasterTickets.TMPurchasedEventInfo.Venue.Address, b: TicketmasterTickets.TMPurchasedEventInfo.Venue.Address) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct Location : Swift.Codable, Swift.Hashable {
      public let latitude: Swift.String?
      public let longitude: Swift.String?
      public var coordinate: CoreLocation.CLLocationCoordinate2D? {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: TicketmasterTickets.TMPurchasedEventInfo.Venue.Location, b: TicketmasterTickets.TMPurchasedEventInfo.Venue.Location) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMPurchasedEventInfo.Venue, b: TicketmasterTickets.TMPurchasedEventInfo.Venue) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Attraction : Swift.Codable, Swift.Hashable {
    public let identifier: Swift.String?
    public let name: Swift.String?
    public let type: Swift.String?
    public let url: Foundation.URL?
    public let locale: Swift.String?
    public let test: Swift.Bool?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMPurchasedEventInfo.Attraction, b: TicketmasterTickets.TMPurchasedEventInfo.Attraction) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Order : Swift.Codable, Swift.Hashable {
    public let orderId: Swift.String?
    public let displayOrderId: Swift.String?
    public let legacyOrderId: Swift.String?
    public let encodedOrderId: Swift.String?
    public let orderStatus: Swift.String?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMPurchasedEventInfo.Order, b: TicketmasterTickets.TMPurchasedEventInfo.Order) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct DateInfo : Swift.Codable, Swift.Hashable {
    public let isMultiDay: Swift.Bool
    public let dateAtVenueString: Swift.String?
    public let endDateAtVenueString: Swift.String?
    public let dateTimeAtVenueString: Swift.String?
    public let dateTimeUTCString: Swift.String?
    public let dateTimeUTC: Foundation.Date?
    public let timezone: Foundation.TimeZone?
    public let hasDateOverride: Swift.Bool
    public let dateOverrideText: Swift.String?
    public let hasTimeOverride: Swift.Bool
    public let timeOverrideText: Swift.String?
    public let displayDateTimeText: Swift.String?
    public let actualDisplayDateTimeText: Swift.String
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMPurchasedEventInfo.DateInfo, b: TicketmasterTickets.TMPurchasedEventInfo.DateInfo) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct PromoterBranding : Swift.Codable, Swift.Hashable {
    public let colorString: Swift.String
    public func color() -> UIKit.UIColor?
    public let logo1xUrl: Foundation.URL?
    public let logo2xUrl: Foundation.URL?
    public let logo3xUrl: Foundation.URL?
    public func logoForScreenScale() -> Foundation.URL?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMPurchasedEventInfo.PromoterBranding, b: TicketmasterTickets.TMPurchasedEventInfo.PromoterBranding) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct HealthCheck : Swift.Codable, Swift.Hashable {
    public let provider: Swift.String?
    public let smallIcon: Foundation.URL?
    public let largeIcon: Foundation.URL?
    public let summary: Swift.String?
    public let checkDescription: Swift.String?
    public let learnMoreUrl: Foundation.URL?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMPurchasedEventInfo.HealthCheck, b: TicketmasterTickets.TMPurchasedEventInfo.HealthCheck) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct TicketManagement : Swift.Codable, Swift.Hashable {
    public let isEnabled: Swift.Bool?
    public let url: Foundation.URL?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMPurchasedEventInfo.TicketManagement, b: TicketmasterTickets.TMPurchasedEventInfo.TicketManagement) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum EventSource : Swift.String, Swift.Codable {
    case host
    case archtics
    case sportXR
    case microflex
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TicketmasterTickets.TMPurchasedEventInfo, b: TicketmasterTickets.TMPurchasedEventInfo) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@inlinable internal func rotateLeft(_ value: Swift.UInt8, by: Swift.UInt8) -> Swift.UInt8 {
  ((value << by) & 0xff) | (value >> (8 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  ((value << by) & 0xffff) | (value >> (16 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  ((value << by) & 0xffffffff) | (value >> (32 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  (value << by) | (value >> (64 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  (value >> by) | (value << (16 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  (value >> by) | (value << (32 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  ((value >> by) | (value << (64 - by)))
}
@inlinable internal func reversed(_ uint8: Swift.UInt8) -> Swift.UInt8 {
  var v = uint8
  v = (v & 0xf0) >> 4 | (v & 0x0f) << 4
  v = (v & 0xcc) >> 2 | (v & 0x33) << 2
  v = (v & 0xaa) >> 1 | (v & 0x55) << 1
  return v
}
@inlinable internal func reversed(_ uint32: Swift.UInt32) -> Swift.UInt32 {
  var v = uint32
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1)
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2)
  v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4)
  v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8)
  v = ((v >> 16) & 0xffff) | ((v & 0xffff) << 16)
  return v
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.ArraySlice<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  return xor(left, right).slice
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.Array<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  let length = Swift.min(left.count, right.count)

  let buf = UnsafeMutablePointer<UInt8>.allocate(capacity: length)
  buf.initialize(repeating: 0, count: length)
  defer {
    buf.deinitialize(count: length)
    buf.deallocate()
  }

   
  for i in 0..<length {
    buf[i] = left[left.startIndex.advanced(by: i)] ^ right[right.startIndex.advanced(by: i)]
  }

  return Array(UnsafeBufferPointer(start: buf, count: length))
}
@inline(__always) @inlinable internal func bitPadding(to data: inout Swift.Array<Swift.UInt8>, blockSize: Swift.Int, allowance: Swift.Int = 0) {
  let msgLength = data.count
   
   
  data.append(0x80)

   
  let max = blockSize - allowance  
  if msgLength % blockSize < max {  
    data += Array<UInt8>(repeating: 0, count: max - 1 - (msgLength % blockSize))
  } else {
    data += Array<UInt8>(repeating: 0, count: blockSize + max - 1 - (msgLength % blockSize))
  }
}
extension TicketmasterTickets.TMTickets {
  final public var navBarButtonTitle: Swift.String? {
    get
    set
  }
}
public protocol TMTicketsModuleDelegate : AnyObject {
  func addCustomModules(event: TicketmasterTickets.TMPurchasedEvent, completion: @escaping (_ customModuleArray: [TicketmasterTickets.TMTicketsModule]?) -> Swift.Void)
  func handleModuleActionButton(event: TicketmasterTickets.TMPurchasedEvent, module: TicketmasterTickets.TMTicketsModule, button: TicketmasterTickets.TMTicketsModule.ActionButton, completion: @escaping (_ openWebpageSettings: TicketmasterTickets.TMTicketsModule.WebpageSettings?) -> Swift.Void)
}
public struct TMPurchasedTicket : Swift.Codable, Swift.Hashable {
  public let identifier: Swift.String?
  public let uniqueEventIdentifier: Swift.String?
  public let eventIdentifier: Swift.String?
  public let externalEventIdentifier: Swift.String?
  public let eventName: Swift.String?
  public let eventCode: Swift.String?
  public let paramRef: Swift.String?
  public let ticketType: Swift.String?
  public let extendedTicketType: Swift.String?
  public let ticketDescription: Swift.String?
  public let productType: Swift.String?
  public let isHostTicket: Swift.Bool?
  public let isStreamingTicket: Swift.Bool?
  public let isThirdPartyResale: Swift.Bool?
  public let ticketSource: Swift.String?
  public let ticketTextLines: [Swift.String]?
  public let termsAndConditions: Swift.String?
  public let hostBranding: TicketmasterTickets.TMPurchasedTicket.HostBranding?
  public let vipColor: TicketmasterTickets.TMPurchasedTicket.Color?
  public let vipText: Swift.String?
  public let isMfaOnViewBarcodeEnabled: Swift.Bool?
  public let entryGate: Swift.String?
  public let sectionName: Swift.String?
  public let rowName: Swift.String?
  public let seatName: Swift.String?
  public let seatType: Swift.String?
  public let seatFrom: Swift.String?
  public let seatThru: Swift.String?
  public let deliveryInfo: TicketmasterTickets.TMPurchasedTicket.Delivery?
  public let deliveryServiceType: Swift.String?
  public let barcodeRenderStatus: Swift.String?
  public let ticketStatus: Swift.String?
  public let transferAvailabilityStatus: Swift.String?
  public let resaleAvailabilityStatus: Swift.String?
  public let sellButtonOverrideURL: Foundation.URL?
  public let orderUpgradeEligibility: Swift.String?
  public let orderIdentifier: Swift.String?
  public let displayOrderIdentifier: Swift.String?
  public let encodedOrderIdentifier: Swift.String?
  public let isOrdersApi: Swift.Bool?
  public let isGlobal: Swift.Bool?
  public let sellManageListingsOverrideURL: Foundation.URL?
  public let orderStatus: Swift.String?
  public let purchaseDate: Foundation.Date?
  public let ticketFees: [TicketmasterTickets.TMPurchasedTicket.TicketFee]?
  public let originalTicketPrice: Swift.Double?
  public let orderSource: Swift.String?
  public let printStatus: Swift.String?
  public let printEligibility: Swift.String?
  public let eventCPRStatus: Swift.String?
  public let moreActionsStatus: Swift.String?
  public let seatUpgradeExchangeStatus: Swift.String?
  public let priceCode: TicketmasterTickets.TMPurchasedTicket.PriceCode?
  public struct TicketFee : Swift.Codable, Swift.Hashable {
    public let feeDescription: Swift.String?
    public let type: Swift.String?
    public let amount: Swift.Double?
    public let currency: Swift.String?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMPurchasedTicket.TicketFee, b: TicketmasterTickets.TMPurchasedTicket.TicketFee) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Delivery : Swift.Codable, Swift.Hashable {
    public let status: Swift.String?
    public let source: TicketmasterTickets.TMPurchasedTicket.Delivery.Source?
    public let deliveryDate: Foundation.Date?
    public let segmentType: TicketmasterTickets.TMPurchasedTicket.Delivery.SegmentType?
    public let trackingNumber: Swift.String?
    public let descriptionLine1: Swift.String?
    public let descriptionLine2: Swift.String?
    public let descriptionLine3: Swift.String?
    public let displayMessage: Swift.String?
    public let methods: [Swift.String]?
    public enum Source : Swift.String, Swift.Codable, Swift.Hashable {
      case flash
      case ups
      case willCall
      case mobileTransfer
      case thirdPartyPrimaryUrl
      case unknown
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum SegmentType : Swift.String, Swift.Codable, Swift.Hashable {
      case barcode
      case nfc
      case rotatingSymbology
      case nfcRotatingSymbology
      case unknown
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMPurchasedTicket.Delivery, b: TicketmasterTickets.TMPurchasedTicket.Delivery) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct HostBranding : Swift.Codable, Swift.Hashable {
    public let headerImageUrl: Foundation.URL?
    public let sponsorImageUrl: Foundation.URL?
    public let termsTitle: Swift.String?
    public let labelColor: TicketmasterTickets.TMPurchasedTicket.Color?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMPurchasedTicket.HostBranding, b: TicketmasterTickets.TMPurchasedTicket.HostBranding) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Color : Swift.Codable, Swift.Hashable {
    public let colorString: Swift.String
    public var color: UIKit.UIColor? {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMPurchasedTicket.Color, b: TicketmasterTickets.TMPurchasedTicket.Color) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct PriceCode : Swift.Codable, Swift.Hashable {
    public let id: Swift.String?
    public let name: Swift.String?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMPurchasedTicket.PriceCode, b: TicketmasterTickets.TMPurchasedTicket.PriceCode) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TicketmasterTickets.TMPurchasedTicket, b: TicketmasterTickets.TMPurchasedTicket) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension TicketmasterTickets.TMTickets {
  public enum TMWebsiteEnvironment : Swift.Codable, Swift.Hashable, Swift.CaseIterable {
    case production
    case alpha
    case beta
    case custom(baseUrlString: Swift.String)
    public static var allCases: [TicketmasterTickets.TMTickets.TMWebsiteEnvironment]
    public var keyValue: Swift.String {
      get
    }
    public init(keyValue: Swift.String)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMTickets.TMWebsiteEnvironment, b: TicketmasterTickets.TMTickets.TMWebsiteEnvironment) -> Swift.Bool
    public typealias AllCases = [TicketmasterTickets.TMTickets.TMWebsiteEnvironment]
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum NAMWebsiteEnvironment : Swift.Codable, Swift.Hashable, Swift.CaseIterable {
    case production
    case staging
    case preProduction
    case qa
    case custom(baseUrlString: Swift.String)
    public static var allCases: [TicketmasterTickets.TMTickets.NAMWebsiteEnvironment]
    public var keyValue: Swift.String {
      get
    }
    public init(keyValue: Swift.String)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMTickets.NAMWebsiteEnvironment, b: TicketmasterTickets.TMTickets.NAMWebsiteEnvironment) -> Swift.Bool
    public typealias AllCases = [TicketmasterTickets.TMTickets.NAMWebsiteEnvironment]
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum ROKTWebsiteEnvironment : Swift.Codable, Swift.Hashable, Swift.CaseIterable {
    case production
    case preProduction
    case custom(baseUrlString: Swift.String)
    public static var allCases: [TicketmasterTickets.TMTickets.ROKTWebsiteEnvironment]
    public var keyValue: Swift.String {
      get
    }
    public init(keyValue: Swift.String)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMTickets.ROKTWebsiteEnvironment, b: TicketmasterTickets.TMTickets.ROKTWebsiteEnvironment) -> Swift.Bool
    public typealias AllCases = [TicketmasterTickets.TMTickets.ROKTWebsiteEnvironment]
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class TMTicketsViewController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency public var addLogoutButton: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @objc deinit
  @_Concurrency.MainActor @preconcurrency public func reload()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension TicketmasterTickets.TMTickets {
  public enum IdType : Swift.String, Swift.Codable, Swift.Hashable {
    case event
    case order
    case any
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ActionType : Swift.String, Swift.Codable, Swift.Hashable {
    case posting
    case transfer
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct BrandingColors : Swift.Codable, Swift.Hashable {
    public let navBar: UIKit.UIColor
    public let button: UIKit.UIColor
    public let text: UIKit.UIColor
    public let ticket: UIKit.UIColor
    public let theme: TicketmasterAuthentication.TMAuthentication.ColorTheme
    public init()
    public init(navBarColor: UIKit.UIColor, buttonColor: UIKit.UIColor, textColor: UIKit.UIColor, ticketColor: UIKit.UIColor, theme: TicketmasterAuthentication.TMAuthentication.ColorTheme)
    public init(color: UIKit.UIColor, theme: TicketmasterAuthentication.TMAuthentication.ColorTheme)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMTickets.BrandingColors, b: TicketmasterTickets.TMTickets.BrandingColors) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension TicketmasterTickets.TMTickets {
  public struct TicketsError {
    public static let domain: Swift.String
    public static let domainTMX: Swift.String
    public static let configurationNotSet: Foundation.NSError
    public static let configurationNotMatched: Foundation.NSError
    public static let configurationServiceNotSet: Foundation.NSError
    public static let configurationInvalidForOperation: Foundation.NSError
    public static let configurationInProgress: Foundation.NSError
    public static let emptyResponse: Foundation.NSError
    public static let unexpectedReponse: Foundation.NSError
    public static let userNotLoggedIn: Foundation.NSError
    public static let userAbortedLogin: Foundation.NSError
    public static let loginWindowMissing: Foundation.NSError
    public static let missingOAuthTokens: Foundation.NSError
    public static let memberInfoConversion: Foundation.NSError
    public static let featureNotSupportedByBackend: Foundation.NSError
    public enum FetchError : Swift.Error {
      case noMatchingEvent
      case noOrders
      case aggregated([any Swift.Error])
      case unspecified
    }
  }
}
extension TicketmasterTickets.TMTickets {
  final public func start(ticketsView: TicketmasterTickets.TMTicketsView, callSource: Swift.String? = nil)
}
@usableFromInline
internal struct BatchedCollectionIndex<Base> where Base : Swift.Collection {
}
extension TicketmasterTickets.BatchedCollectionIndex : Swift.Comparable {
  @usableFromInline
  internal static func == <Base>(lhs: TicketmasterTickets.BatchedCollectionIndex<Base>, rhs: TicketmasterTickets.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
  @usableFromInline
  internal static func < <Base>(lhs: TicketmasterTickets.BatchedCollectionIndex<Base>, rhs: TicketmasterTickets.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
}
@usableFromInline
internal struct BatchedCollection<Base> : Swift.Collection where Base : Swift.Collection {
  @usableFromInline
  internal init(base: Base, size: Swift.Int)
  @usableFromInline
  internal typealias Index = TicketmasterTickets.BatchedCollectionIndex<Base>
  @usableFromInline
  internal var startIndex: TicketmasterTickets.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal var endIndex: TicketmasterTickets.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal func index(after idx: TicketmasterTickets.BatchedCollection<Base>.Index) -> TicketmasterTickets.BatchedCollection<Base>.Index
  @usableFromInline
  internal subscript(idx: TicketmasterTickets.BatchedCollection<Base>.Index) -> Base.SubSequence {
    get
  }
  @usableFromInline
  internal typealias Element = Base.SubSequence
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<TicketmasterTickets.BatchedCollection<Base>>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<TicketmasterTickets.BatchedCollection<Base>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<TicketmasterTickets.BatchedCollection<Base>>
}
extension Swift.Collection {
  @inlinable internal func batched(by size: Swift.Int) -> TicketmasterTickets.BatchedCollection<Self> {
    BatchedCollection(base: self, size: size)
  }
}
extension TicketmasterTickets.TMTicketsModule {
  public static func module(jsonDict: TicketmasterFoundation.JSONDictionary?, event: TicketmasterTickets.TMPurchasedEvent, completion: @escaping (_ modules: [TicketmasterTickets.TMTicketsModule]) -> Swift.Void)
}
extension UIKit.UIFont {
  public enum SourceSansFontFilenames : Swift.String, Swift.CaseIterable {
    case regular
    case bold
    case semibold
    case black
    public init?(rawValue: Swift.String)
    @available(iOS 2.0, *)
    public typealias AllCases = [UIKit.UIFont.SourceSansFontFilenames]
    @available(iOS 2.0, *)
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [UIKit.UIFont.SourceSansFontFilenames] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public static func tmFontRegular(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func tmFontBold(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func tmFontSemibold(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func tmFontBlack(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
}
extension TicketmasterTickets.TMTicketsPrebuiltModule.HeaderOverride {
  public init(jsonDict: TicketmasterFoundation.JSONDictionary?)
}
extension TicketmasterTickets.TMTicketsPrebuiltModule {
  public struct HeaderOverride {
    public let topLabelText: Swift.String?
    public let topLabelTextAlignment: UIKit.NSTextAlignment?
    public let topLabelTextColor: UIKit.UIColor?
    public let centerLabelText: Swift.String?
    public let centerLabelTextAlignment: UIKit.NSTextAlignment?
    public let centerLabelTextColor: UIKit.UIColor?
    public let bottomLabelText: Swift.String?
    public let bottomLabelTextAlignment: UIKit.NSTextAlignment?
    public let bottomLabelTextColor: UIKit.UIColor?
    public let titleLabelText: Swift.String?
    public let titleLabelTextColor: UIKit.UIColor?
    public let messageLabelText: Swift.String?
    public let messageLabelTextColor: UIKit.UIColor?
    public let messageLabelDetectLinks: Swift.Bool?
    public let messageLabelLinkColor: UIKit.UIColor?
    public let titleMessageBackgroundColor: UIKit.UIColor?
    public let gradientAlpha: CoreFoundation.CGFloat?
    public let backgroundAspectRatio: CoreFoundation.CGFloat?
    public let backgroundColor: UIKit.UIColor?
    public let backgroundImage: UIKit.UIImage?
    public let backgroundImageURL: Foundation.URL?
    public init(topLabelText: Swift.String? = nil, topLabelTextAlignment: UIKit.NSTextAlignment? = nil, topLabelTextColor: UIKit.UIColor? = nil, centerLabelText: Swift.String? = nil, centerLabelTextAlignment: UIKit.NSTextAlignment? = nil, centerLabelTextColor: UIKit.UIColor? = nil, bottomLabelText: Swift.String? = nil, bottomLabelTextAlignment: UIKit.NSTextAlignment? = nil, bottomLabelTextColor: UIKit.UIColor? = nil, titleLabelText: Swift.String? = nil, titleLabelTextColor: UIKit.UIColor? = nil, messageLabelText: Swift.String? = nil, messageLabelTextColor: UIKit.UIColor? = nil, messageLabelDetectLinks: Swift.Bool? = nil, messageLabelLinkColor: UIKit.UIColor? = nil, titleMessageBackgroundColor: UIKit.UIColor? = nil, gradientAlpha: CoreFoundation.CGFloat? = nil, backgroundAspectRatio: CoreFoundation.CGFloat? = nil, backgroundColor: UIKit.UIColor? = nil, backgroundImage: UIKit.UIImage? = nil, backgroundImageURL: Foundation.URL? = nil)
  }
}
extension Swift.Collection where Self.Element == Swift.UInt8, Self.Index == Swift.Int {
  @inlinable internal func toUInt32Array() -> Swift.Array<Swift.UInt32> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 4)
    return Array<UInt32>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 4) {
        let val = UInt32(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
  @inlinable internal func toUInt64Array() -> Swift.Array<Swift.UInt64> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 8)
    return Array<UInt64>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 8) {
        let val = UInt64(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
}
@usableFromInline
internal func strideCount(from: Swift.Int, to: Swift.Int, by: Swift.Int) -> Swift.Int
public struct TMPurchasedEvent : Swift.Codable, Swift.Hashable {
  public let info: TicketmasterTickets.TMPurchasedEventInfo
  public let orders: [TicketmasterTickets.TMPurchasedOrder]?
  public let selectedOrder: TicketmasterTickets.TMPurchasedOrder?
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TicketmasterTickets.TMPurchasedEvent, b: TicketmasterTickets.TMPurchasedEvent) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension TicketmasterTickets.TMTicketsModuleHeaderView {
  @discardableResult
  @_Concurrency.MainActor @preconcurrency final public func configure(topLabelText: Swift.String? = nil, topLabelTextAlignment: UIKit.NSTextAlignment? = .left, topLabelTextColor: UIKit.UIColor? = nil, centerLabelText: Swift.String? = nil, centerLabelTextAlignment: UIKit.NSTextAlignment? = .center, centerLabelTextColor: UIKit.UIColor? = nil, bottomLabelText: Swift.String? = nil, bottomLabelTextAlignment: UIKit.NSTextAlignment? = .right, bottomLabelTextColor: UIKit.UIColor? = nil, titleLabelText: Swift.String? = nil, titleLabelTextColor: UIKit.UIColor? = nil, messageLabelText: Swift.String? = nil, messageLabelTextColor: UIKit.UIColor? = nil, messageLabelDetectLinks: Swift.Bool = true, messageLabelLinkColor: UIKit.UIColor? = nil, titleMessageBackgroundColor: UIKit.UIColor? = nil, gradientAlpha: CoreFoundation.CGFloat? = 0.0, backgroundAspectRatio: CoreFoundation.CGFloat? = nil, backgroundAspectRatioForced: Swift.Bool = false, backgroundColor: UIKit.UIColor? = nil, backgroundImage: UIKit.UIImage? = nil, backgroundImageURL: Foundation.URL? = nil, mapCoordinateRegion: MapKit.MKCoordinateRegion? = nil, mapAnnotation: (any MapKit.MKAnnotation)? = nil, avContentURL: Foundation.URL? = nil, disableLoopingContent: Swift.Bool = false, disableAVAudio: Swift.Bool = false, barcode2DValue: Swift.String? = nil, qrCodeValue: Swift.String? = nil, aztecValue: Swift.String? = nil, pdf417Value: Swift.String? = nil, headerOverride: TicketmasterTickets.TMTicketsPrebuiltModule.HeaderOverride? = nil) -> Swift.Bool
}
extension TicketmasterTickets.TMTickets {
  final public func display(orderOrEventId: Swift.String, type: TicketmasterTickets.TMTickets.IdType = .any, action: TicketmasterTickets.TMTickets.ActionType? = nil, callSource: Swift.String? = nil)
}
public protocol TMTicketsAnalyticsDelegate : AnyObject {
  func userDidView(page: TicketmasterTickets.TMTickets.Analytics.Page, metadata: TicketmasterTickets.TMTickets.Analytics.MetadataType)
  func userDidPerform(action: TicketmasterTickets.TMTickets.Analytics.Action, metadata: TicketmasterTickets.TMTickets.Analytics.MetadataType)
}
extension TicketmasterTickets.TMTickets {
  public struct Analytics : Swift.Codable, Swift.Hashable {
    public enum Page : Swift.String {
      case events
      case eventTickets
      case eventModules
      case eventModulesV2
      case ticketBarcode
      case ticketDelivery
      case ticketDetails
      case mfaForTicketOperation
      case mfaForViewBarcode
      case mfaForWebpage
      case eventInfoBanner
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum Action : Swift.String {
      case addTicketToWalletButton
      case barcodeScreenshot
      case transferSendButton
      case transferCancelButton
      case postingEditButton
      case postingCancelButton
      case eventInfoBannerButton
      case moduleActionButton
      case moduleActionButtonV2
      case pullToRefreshEvents
      case retryErrorButton
      case logoutErrorButton
      case customErrorButton
      case navbarButtonAction
      case addTicketToWalletFinished
      case addTicketToWalletCanceled
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum MetadataType {
      case events(events: [TicketmasterTickets.TMPurchasedEvent])
      case event(event: TicketmasterTickets.TMPurchasedEvent)
      case eventTickets(event: TicketmasterTickets.TMPurchasedEvent, tickets: [TicketmasterTickets.TMPurchasedTicket])
      case eventTicket(event: TicketmasterTickets.TMPurchasedEvent, ticket: TicketmasterTickets.TMPurchasedTicket)
      case module(event: TicketmasterTickets.TMPurchasedEvent, module: TicketmasterTickets.TMTicketsModule)
      case moduleV2(event: TicketmasterTickets.TMPurchasedEvent, moduleID: Swift.String)
      case moduleButton(event: TicketmasterTickets.TMPurchasedEvent, module: TicketmasterTickets.TMTicketsModule, button: TicketmasterTickets.TMTicketsModule.ActionButton)
      case moduleButtonV2(event: TicketmasterTickets.TMPurchasedEvent, moduleID: Swift.String, analyticsValue: Swift.String)
      case empty
      public var description: Swift.String {
        get
      }
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TicketmasterTickets.TMTickets.Analytics, b: TicketmasterTickets.TMTickets.Analytics) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension TicketmasterTickets.TMTickets {
  final public func addCustomErrorPageButton(title: Swift.String?)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class TMTicketsView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame rect: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func awakeFromNib()
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func willMove(toWindow newWindow: UIKit.UIWindow?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func didMoveToWindow()
  @_Concurrency.MainActor @preconcurrency public func reload()
}
extension Swift.UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
public struct TMPurchasedOrder : Swift.Codable, Swift.Hashable, Swift.Comparable {
  public let orderIdentifier: Swift.String
  public let displayableOrderIdentifier: Swift.String
  public let encodedOrderIdentifier: Swift.String?
  public let tickets: [TicketmasterTickets.TMPurchasedTicket]
  public static func < (lhs: TicketmasterTickets.TMPurchasedOrder, rhs: TicketmasterTickets.TMPurchasedOrder) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TicketmasterTickets.TMPurchasedOrder, b: TicketmasterTickets.TMPurchasedOrder) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension TicketmasterTickets.TMTicketsPrebuiltModule {
  public static func currentPromotionalModules(event: TicketmasterTickets.TMPurchasedEvent, appPromoKey: Swift.String, completion: @escaping (_ promotionalModules: [TicketmasterTickets.TMTicketsModule]) -> Swift.Void)
}
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
extension Swift.UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class TMTickets : ObjectiveC.NSObject {
  public static let shared: TicketmasterTickets.TMTickets
  final public var version: Swift.String {
    get
  }
  final public var secureEntryVersion: Swift.String {
    get
  }
  final public var sdkBuildInfo: TicketmasterFoundation.JSONDictionary? {
    get
  }
  weak final public var orderDelegate: (any TicketmasterTickets.TMTicketsOrderDelegate)?
  weak final public var moduleDelegate: (any TicketmasterTickets.TMTicketsModuleDelegate)?
  weak final public var analyticsDelegate: (any TicketmasterTickets.TMTicketsAnalyticsDelegate)?
  @available(*, deprecated, message: "Use doNotPresentPrimaryLoginIfSecondaryLoggedIn instead")
  final public var doNotPresentTeamLoginIfHostLoggedIn: Swift.Bool {
    get
    set
  }
  final public var doNotPresentPrimaryLoginIfSecondaryLoggedIn: Swift.Bool
  @objc deinit
}
@objc public class TMTicketsModule : ObjectiveC.NSObject, Swift.Comparable {
  final public let identifier: Swift.String
  final public let headerDisplay: TicketmasterTickets.TMTicketsModule.HeaderDisplay?
  public var actionButtons: [TicketmasterTickets.TMTicketsModule.ActionButton]?
  public init(identifier: Swift.String, headerDisplay: TicketmasterTickets.TMTicketsModule.HeaderDisplay? = nil, actionButtons: [TicketmasterTickets.TMTicketsModule.ActionButton]? = nil)
  public static func < (lhs: TicketmasterTickets.TMTicketsModule, rhs: TicketmasterTickets.TMTicketsModule) -> Swift.Bool
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc public class HeaderDisplay : ObjectiveC.NSObject {
    public static let defaultSize: CoreFoundation.CGSize
    final public let image: UIKit.UIImage?
    final public let view: UIKit.UIView?
    public init(image: UIKit.UIImage)
    public init(view: UIKit.UIView)
    @objc deinit
  }
  @objc public class ActionButton : ObjectiveC.NSObject {
    final public let title: Swift.String
    final public let titleColor: UIKit.UIColor?
    final public let buttonColor: UIKit.UIColor?
    final public let callbackValue: Swift.String
    final public let webpageSettings: TicketmasterTickets.TMTicketsModule.WebpageSettings?
    final public let requiresSpecificOrder: Swift.Bool
    final public let walletSettings: TicketmasterTickets.TMTicketsModule.WalletSettings?
    final public let mapLocation: TicketmasterTickets.TMTicketsModule.MapLocation?
    public var enabled: Swift.Bool
    public init(title: Swift.String, titleColor: UIKit.UIColor? = nil, buttonColor: UIKit.UIColor? = nil, callbackValue: Swift.String? = nil, requiresSpecificOrder: Swift.Bool = false, enabled: Swift.Bool = true)
    public init(title: Swift.String, titleColor: UIKit.UIColor? = nil, buttonColor: UIKit.UIColor? = nil, callbackValue: Swift.String? = nil, webpageSettings: TicketmasterTickets.TMTicketsModule.WebpageSettings, requiresSpecificOrder: Swift.Bool = false, enabled: Swift.Bool = true)
    public init(title: Swift.String, titleColor: UIKit.UIColor? = nil, buttonColor: UIKit.UIColor? = nil, callbackValue: Swift.String? = nil, walletSettings: TicketmasterTickets.TMTicketsModule.WalletSettings, enabled: Swift.Bool = true)
    public init(title: Swift.String, titleColor: UIKit.UIColor? = nil, buttonColor: UIKit.UIColor? = nil, callbackValue: Swift.String? = nil, mapLocation: TicketmasterTickets.TMTicketsModule.MapLocation, enabled: Swift.Bool = true)
    @objc deinit
  }
  @objc public class WebpageSettings : ObjectiveC.NSObject {
    public var pageTitle: Swift.String?
    public var urlRequest: Foundation.URLRequest
    public var openExternalURL: Swift.Bool
    public var internalPresentationStyle: UIKit.UIModalPresentationStyle?
    public var reloadTicketInfo: Swift.Bool
    public var oauthCookieSettingsArray: [TicketmasterTickets.TMTicketsModule.OAuthCookieSettings]?
    public init(pageTitle: Swift.String? = nil, urlRequest: Foundation.URLRequest, openExternalURL: Swift.Bool? = false, internalPresentationStyle: UIKit.UIModalPresentationStyle? = nil, reloadTicketInfo: Swift.Bool? = false, oauthCookieSettingsArray: [TicketmasterTickets.TMTicketsModule.OAuthCookieSettings]? = nil)
    public init(pageTitle: Swift.String? = nil, urlRequest: Foundation.URLRequest, openExternalURL: Swift.Bool? = false, internalPresentationStyle: UIKit.UIModalPresentationStyle? = nil, reloadTicketInfo: Swift.Bool? = false, oauthCookieSettings: TicketmasterTickets.TMTicketsModule.OAuthCookieSettings?)
    @objc deinit
  }
  @objc public class OAuthCookieSettings : ObjectiveC.NSObject {
    public var name: Swift.String
    public var value: Swift.String?
    public var webDomains: [Swift.String]
    public var backend: TicketmasterAuthentication.TMAuthentication.BackendService?
    public var backendTokenType: TicketmasterTickets.TMTicketsModule.OAuthCookieSettings.BackendTokenType
    public enum BackendTokenType : Swift.String {
      case accessToken
      case idToken
      case hmacId
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public init(name: Swift.String, webDomains: [Swift.String], backend: TicketmasterAuthentication.TMAuthentication.BackendService? = nil, backendTokenType: TicketmasterTickets.TMTicketsModule.OAuthCookieSettings.BackendTokenType = .accessToken)
    public init(name: Swift.String, value: Swift.String?, webDomains: [Swift.String])
    @objc deinit
  }
  @objc public class MapLocation : ObjectiveC.NSObject {
    final public let name: Swift.String?
    final public let coordinates: CoreLocation.CLLocationCoordinate2D
    public init(name: Swift.String? = nil, coordinates: CoreLocation.CLLocationCoordinate2D)
    @objc deinit
  }
  @objc public class WalletSettings : ObjectiveC.NSObject {
    final public let url: Foundation.URL?
    final public let useTMBackend: Swift.Bool
    final public let requiresAccountBinding: Swift.Bool
    public var binary: PassKit.PKPass?
    public init(url: Foundation.URL? = nil, useTMBackend: Swift.Bool = false, requiresAccountBinding: Swift.Bool = false, binary: PassKit.PKPass? = nil)
    @objc deinit
  }
  @objc deinit
}
extension Swift.Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
    self = Array<Element>()
    self.reserveCapacity(reserveCapacity)
  }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
    self[self.startIndex ..< self.endIndex]
  }
  }
}
extension TicketmasterTickets.TMTicketsPrebuiltModule.ModuleName : Swift.Equatable {}
extension TicketmasterTickets.TMTicketsPrebuiltModule.ModuleName : Swift.Hashable {}
extension TicketmasterTickets.TMTicketsPrebuiltModule.ModuleName : Swift.RawRepresentable {}
extension TicketmasterTickets.TMTicketsPrebuiltModule.ButtonCallbackName : Swift.Equatable {}
extension TicketmasterTickets.TMTicketsPrebuiltModule.ButtonCallbackName : Swift.Hashable {}
extension TicketmasterTickets.TMTicketsPrebuiltModule.ButtonCallbackName : Swift.RawRepresentable {}
extension TicketmasterTickets.TMPurchasedEventInfo.EventSource : Swift.Equatable {}
extension TicketmasterTickets.TMPurchasedEventInfo.EventSource : Swift.Hashable {}
extension TicketmasterTickets.TMPurchasedEventInfo.EventSource : Swift.RawRepresentable {}
extension TicketmasterTickets.TMPurchasedTicket.Delivery.Source : Swift.RawRepresentable {}
extension TicketmasterTickets.TMPurchasedTicket.Delivery.SegmentType : Swift.RawRepresentable {}
extension TicketmasterTickets.TMTickets.IdType : Swift.RawRepresentable {}
extension TicketmasterTickets.TMTickets.ActionType : Swift.RawRepresentable {}
extension UIKit.UIFont.SourceSansFontFilenames : Swift.Equatable {}
extension UIKit.UIFont.SourceSansFontFilenames : Swift.Hashable {}
extension UIKit.UIFont.SourceSansFontFilenames : Swift.RawRepresentable {}
extension TicketmasterTickets.TMTickets.Analytics.Page : Swift.Equatable {}
extension TicketmasterTickets.TMTickets.Analytics.Page : Swift.Hashable {}
extension TicketmasterTickets.TMTickets.Analytics.Page : Swift.RawRepresentable {}
extension TicketmasterTickets.TMTickets.Analytics.Action : Swift.Equatable {}
extension TicketmasterTickets.TMTickets.Analytics.Action : Swift.Hashable {}
extension TicketmasterTickets.TMTickets.Analytics.Action : Swift.RawRepresentable {}
extension TicketmasterTickets.TMTicketsModule.OAuthCookieSettings.BackendTokenType : Swift.Equatable {}
extension TicketmasterTickets.TMTicketsModule.OAuthCookieSettings.BackendTokenType : Swift.Hashable {}
extension TicketmasterTickets.TMTicketsModule.OAuthCookieSettings.BackendTokenType : Swift.RawRepresentable {}
